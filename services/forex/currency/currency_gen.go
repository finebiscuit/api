// Code generated by "enumer -type=Currency -trimprefix Currency -output=currency_gen.go -gqlgen -sql -json -text"; DO NOT EDIT.

package currency

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"io"
	"strconv"
	"strings"
)

const _CurrencyName = "XXXXTSAUDCADEURJPYNZDNOKGBPSEKCHFUSDRUBTRYDKKPLNHUFCZKILSAEDRONBGNRSDUAHXAGXAUXPTXPDBCHBTCETHLTCXRP"

var _CurrencyIndex = [...]uint8{0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99}

const _CurrencyLowerName = "xxxxtsaudcadeurjpynzdnokgbpsekchfusdrubtrydkkplnhufczkilsaedronbgnrsduahxagxauxptxpdbchbtcethltcxrp"

func (i Currency) String() string {
	if i >= Currency(len(_CurrencyIndex)-1) {
		return fmt.Sprintf("Currency(%d)", i)
	}
	return _CurrencyName[_CurrencyIndex[i]:_CurrencyIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _CurrencyNoOp() {
	var x [1]struct{}
	_ = x[XXX-(0)]
	_ = x[XTS-(1)]
	_ = x[AUD-(2)]
	_ = x[CAD-(3)]
	_ = x[EUR-(4)]
	_ = x[JPY-(5)]
	_ = x[NZD-(6)]
	_ = x[NOK-(7)]
	_ = x[GBP-(8)]
	_ = x[SEK-(9)]
	_ = x[CHF-(10)]
	_ = x[USD-(11)]
	_ = x[RUB-(12)]
	_ = x[TRY-(13)]
	_ = x[DKK-(14)]
	_ = x[PLN-(15)]
	_ = x[HUF-(16)]
	_ = x[CZK-(17)]
	_ = x[ILS-(18)]
	_ = x[AED-(19)]
	_ = x[RON-(20)]
	_ = x[BGN-(21)]
	_ = x[RSD-(22)]
	_ = x[UAH-(23)]
	_ = x[XAG-(24)]
	_ = x[XAU-(25)]
	_ = x[XPT-(26)]
	_ = x[XPD-(27)]
	_ = x[BCH-(28)]
	_ = x[BTC-(29)]
	_ = x[ETH-(30)]
	_ = x[LTC-(31)]
	_ = x[XRP-(32)]
}

var _CurrencyValues = []Currency{XXX, XTS, AUD, CAD, EUR, JPY, NZD, NOK, GBP, SEK, CHF, USD, RUB, TRY, DKK, PLN, HUF, CZK, ILS, AED, RON, BGN, RSD, UAH, XAG, XAU, XPT, XPD, BCH, BTC, ETH, LTC, XRP}

var _CurrencyNameToValueMap = map[string]Currency{
	_CurrencyName[0:3]:        XXX,
	_CurrencyLowerName[0:3]:   XXX,
	_CurrencyName[3:6]:        XTS,
	_CurrencyLowerName[3:6]:   XTS,
	_CurrencyName[6:9]:        AUD,
	_CurrencyLowerName[6:9]:   AUD,
	_CurrencyName[9:12]:       CAD,
	_CurrencyLowerName[9:12]:  CAD,
	_CurrencyName[12:15]:      EUR,
	_CurrencyLowerName[12:15]: EUR,
	_CurrencyName[15:18]:      JPY,
	_CurrencyLowerName[15:18]: JPY,
	_CurrencyName[18:21]:      NZD,
	_CurrencyLowerName[18:21]: NZD,
	_CurrencyName[21:24]:      NOK,
	_CurrencyLowerName[21:24]: NOK,
	_CurrencyName[24:27]:      GBP,
	_CurrencyLowerName[24:27]: GBP,
	_CurrencyName[27:30]:      SEK,
	_CurrencyLowerName[27:30]: SEK,
	_CurrencyName[30:33]:      CHF,
	_CurrencyLowerName[30:33]: CHF,
	_CurrencyName[33:36]:      USD,
	_CurrencyLowerName[33:36]: USD,
	_CurrencyName[36:39]:      RUB,
	_CurrencyLowerName[36:39]: RUB,
	_CurrencyName[39:42]:      TRY,
	_CurrencyLowerName[39:42]: TRY,
	_CurrencyName[42:45]:      DKK,
	_CurrencyLowerName[42:45]: DKK,
	_CurrencyName[45:48]:      PLN,
	_CurrencyLowerName[45:48]: PLN,
	_CurrencyName[48:51]:      HUF,
	_CurrencyLowerName[48:51]: HUF,
	_CurrencyName[51:54]:      CZK,
	_CurrencyLowerName[51:54]: CZK,
	_CurrencyName[54:57]:      ILS,
	_CurrencyLowerName[54:57]: ILS,
	_CurrencyName[57:60]:      AED,
	_CurrencyLowerName[57:60]: AED,
	_CurrencyName[60:63]:      RON,
	_CurrencyLowerName[60:63]: RON,
	_CurrencyName[63:66]:      BGN,
	_CurrencyLowerName[63:66]: BGN,
	_CurrencyName[66:69]:      RSD,
	_CurrencyLowerName[66:69]: RSD,
	_CurrencyName[69:72]:      UAH,
	_CurrencyLowerName[69:72]: UAH,
	_CurrencyName[72:75]:      XAG,
	_CurrencyLowerName[72:75]: XAG,
	_CurrencyName[75:78]:      XAU,
	_CurrencyLowerName[75:78]: XAU,
	_CurrencyName[78:81]:      XPT,
	_CurrencyLowerName[78:81]: XPT,
	_CurrencyName[81:84]:      XPD,
	_CurrencyLowerName[81:84]: XPD,
	_CurrencyName[84:87]:      BCH,
	_CurrencyLowerName[84:87]: BCH,
	_CurrencyName[87:90]:      BTC,
	_CurrencyLowerName[87:90]: BTC,
	_CurrencyName[90:93]:      ETH,
	_CurrencyLowerName[90:93]: ETH,
	_CurrencyName[93:96]:      LTC,
	_CurrencyLowerName[93:96]: LTC,
	_CurrencyName[96:99]:      XRP,
	_CurrencyLowerName[96:99]: XRP,
}

var _CurrencyNames = []string{
	_CurrencyName[0:3],
	_CurrencyName[3:6],
	_CurrencyName[6:9],
	_CurrencyName[9:12],
	_CurrencyName[12:15],
	_CurrencyName[15:18],
	_CurrencyName[18:21],
	_CurrencyName[21:24],
	_CurrencyName[24:27],
	_CurrencyName[27:30],
	_CurrencyName[30:33],
	_CurrencyName[33:36],
	_CurrencyName[36:39],
	_CurrencyName[39:42],
	_CurrencyName[42:45],
	_CurrencyName[45:48],
	_CurrencyName[48:51],
	_CurrencyName[51:54],
	_CurrencyName[54:57],
	_CurrencyName[57:60],
	_CurrencyName[60:63],
	_CurrencyName[63:66],
	_CurrencyName[66:69],
	_CurrencyName[69:72],
	_CurrencyName[72:75],
	_CurrencyName[75:78],
	_CurrencyName[78:81],
	_CurrencyName[81:84],
	_CurrencyName[84:87],
	_CurrencyName[87:90],
	_CurrencyName[90:93],
	_CurrencyName[93:96],
	_CurrencyName[96:99],
}

// CurrencyString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func CurrencyString(s string) (Currency, error) {
	if val, ok := _CurrencyNameToValueMap[s]; ok {
		return val, nil
	}
	s = strings.ToLower(s)
	if val, ok := _CurrencyNameToValueMap[s]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Currency values", s)
}

// CurrencyValues returns all values of the enum
func CurrencyValues() []Currency {
	return _CurrencyValues
}

// CurrencyStrings returns a slice of all String values of the enum
func CurrencyStrings() []string {
	strs := make([]string, len(_CurrencyNames))
	copy(strs, _CurrencyNames)
	return strs
}

// IsACurrency returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Currency) IsACurrency() bool {
	for _, v := range _CurrencyValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for Currency
func (i Currency) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Currency
func (i *Currency) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Currency should be a string, got %s", data)
	}

	var err error
	*i, err = CurrencyString(s)
	return err
}

// MarshalText implements the encoding.TextMarshaler interface for Currency
func (i Currency) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Currency
func (i *Currency) UnmarshalText(text []byte) error {
	var err error
	*i, err = CurrencyString(string(text))
	return err
}

func (i Currency) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *Currency) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Currency: %[1]T(%[1]v)", value)
	}

	val, err := CurrencyString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for Currency
func (i Currency) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(i.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for Currency
func (i *Currency) UnmarshalGQL(value interface{}) error {
	str, ok := value.(string)
	if !ok {
		return fmt.Errorf("Currency should be a string, got %T", value)
	}

	var err error
	*i, err = CurrencyString(str)
	return err
}
